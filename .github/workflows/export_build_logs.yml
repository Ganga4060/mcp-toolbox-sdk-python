name: Export Cloud Build Failure Logs

# This trigger fires ONCE after all checks for a commit are complete.
on:
  check_suite:
    types: [completed]
  # Allows for manual runs from the Actions tab.
  workflow_dispatch:

jobs:
  #step1: Find any and all failures that match our prefixes.
  detect-build-failure:
    name: Detect Cloud Build Failures
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: read   # Required to read the status of checks
      issues: write # Required later for posting comments
    outputs:
      # This output will be a JSON string of all failed builds
      failure_detected: ${{ steps.detect_failures.outputs.failure_detected }}
      failed_checks: ${{ steps.detect_failures.outputs.failed_checks }}
    steps:
      - name: Detect all failed Cloud Build checks
        id: detect_failures
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // Define all the prefixes you want to monitor
            const prefixes = [
              'core-python-sdk-pr-',
              'langchain-python-sdk-pr-',
              'llamaindex-python-sdk-pr-',
            ];

            const prList = context.payload.check_suite.pull_requests;
            if (!prList || prList.length === 0) {
              core.info('No PR found for this check suite. Skipping.');
              core.setOutput('failure_detected', 'false');
              return;
            }

            const { owner, repo } = context.repo;
            const sha = context.payload.check_suite.head_sha;

            // Get the list of all checks for the commit
            const checks = await github.rest.checks.listForRef({
              owner,
              repo,
              ref: sha,
              per_page: 100
            });

            // Filter that list for checks that match ANY of our prefixes AND have failed
            const failed = checks.data.check_runs.filter(
              c =>
                prefixes.some(prefix => c.name.startsWith(prefix)) &&
                c.status === 'completed' &&
                c.conclusion === 'failure'
            );

            if (failed.length === 0) {
              core.info('No failed Cloud Build checks detected.');
              core.setOutput('failure_detected', 'false');
              return;
            }

            core.info(`Detected ${failed.length} failed build(s).`);
            core.info('Failing build checks:');
            failed.forEach(f => core.info(`- ${f.name}`));
            core.setOutput('failure_detected', 'true');
            // Output the list of failed builds as a JSON string for the next job
            core.setOutput('failed_checks', JSON.stringify(failed.map(f => ({
              name: f.name,
              id: f.id,
              html_url: f.html_url,
              details_url: f.details_url,
              external_id: f.external_id || ''
            }))));

  # step 2: Process each failure found in Job 1.
  process-failed-builds:
    # This job depends on the successful completion of the detection job.
    needs: detect-build-failure
    # Only run this job if the first job actually found failures.
    if: needs.detect-build-failure.outputs.failure_detected == 'true'
    runs-on: ubuntu-latest
    env:
      GCLOUD_SERVICE_KEY: ${{ secrets.GCLOUD_SERVICE_KEY }}
    strategy:
      # It creates parallel jobs from the JSON output of the first job.
      matrix:
        include: ${{ fromJson(needs.detect-build-failure.outputs.failed_checks) }}
    steps:
      - name: Parse build ID and set project ID
        id: parse_build_info
        run: |
          details_url="${{ matrix.details_url }}"
          build_id=$(echo "$details_url" | sed -n 's#.*/builds/\([^?]*\).*#\1#p')
          project_id=$(echo '${{ env.GCLOUD_SERVICE_KEY }}' | jq -r '.project_id')
          echo "Build ID: $build_id"
          echo "build_id=$build_id" >> $GITHUB_OUTPUT
          echo "project_id=$project_id" >> $GITHUB_OUTPUT

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ env.GCLOUD_SERVICE_KEY }}

      - name: Fetch Cloud Build logs
        id: fetch_cloud_build_logs
        run: |
          LOG_FILE="cloudbuild_error_logs.txt"
          gcloud builds log "${{ steps.parse_build_info.outputs.build_id }}" \
            --project="${{ steps.parse_build_info.outputs.project_id }}" > "${LOG_FILE}" 2>&1 || true

          if [ ! -s "${LOG_FILE}" ]; then
            echo "Warning: No logs found with gcloud builds log. See the web UI for full logs:" > "${LOG_FILE}"
            echo "Log URL: ${{ matrix.details_url }}" >> "${LOG_FILE}"
          fi
          echo "log_file_name=${LOG_FILE}" >> $GITHUB_OUTPUT

      - name: Upload Logs as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: logs-${{ matrix.name }}-${{ steps.parse_build_info.outputs.build_id }}
          path: ${{ steps.fetch_cloud_build_logs.outputs.log_file_name }}
          retention-days: 7

      - name: Save artifact info
        run: |
          echo "${{ github.run_id }},${{ matrix.name }}" >> artifact_summary.txt

      - name: Upload artifact info
        uses: actions/upload-artifact@v4
        with:
          name: artifact-summary-${{ matrix.name }}
          path: artifact_summary.txt
# Gather and print artifact summary
  gather-artifacts-summary:
    needs: process-failed-builds
    runs-on: ubuntu-latest
    steps:
      - name: Download all artifact summaries
        uses: actions/download-artifact@v4
        with:
          path: summaries

      - name: Print artifact links
        run: |
          echo "Artifacts for failing build checks:" > artifact_links.txt
          for f in summaries/artifact-summary-*/artifact_summary.txt; do
            while IFS=, read -r run_id check_name; do
              echo "- https://github.com/${{ github.repository }}/actions/runs/$run_id (or) $check_name" >> artifact_links.txt
            done < "$f"
          done
          cat artifact_links.txt

  # step 3: Post one final comment summarizing everything.
  post-pr-comment:
    needs: [detect-build-failure, process-failed-builds, gather-artifacts-summary]
    runs-on: ubuntu-latest
    # Run this job even if some of the log-fetching jobs failed, but ONLY if failures were detected initially.
    if: always() && needs.detect-build-failure.outputs.failure_detected == 'true'
    permissions:
      actions: read   # Permission to list artifacts from the run
      issues: write  # Permission to post comments
    steps:
      - name: Compose and post PR comment with artifact links
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const prList = context.payload.check_suite.pull_requests;
            if (!prList || prList.length === 0) {
              core.info('No PR found, skipping comment.');
              return;
            }
            const pr = prList[0];
            const run_id = context.runId;

            // List artifacts for this workflow run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner,
              repo,
              run_id
            });

            if (!artifacts.data.artifacts.length) {
              core.info('No artifacts found to link in comment.');
              return;
            }

            // Compose the comment body with artifact links and check names
            let body = '### :warning: Cloud Build Failure\n\n';
            body += 'Artifacts for failing build checks:\n';
            // Read artifact_links.txt generated in gather-artifacts-summary
            const fs = require('fs');
            const artifactLinks = fs.readFileSync('artifact_links.txt', 'utf8');
            body += artifactLinks + '\n';
            body += '\n---\n*This comment was automatically generated by the CI workflow.*';

            // Try to find an existing bot comment to update (avoid duplicates)
            const comments = await github.rest.issues.listComments({
              owner,
              repo,
              issue_number: pr.number,
              per_page: 100
            });
            const botLogin = context.actor;
            const existing = comments.data.find(c =>
              c.user && c.user.login === botLogin && c.body && c.body.includes('Cloud Build Failure')
            );
            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
              core.info('Updated existing bot comment.');
            } else {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: pr.number,
                body
              });
              core.info('Posted new bot comment.');
            }